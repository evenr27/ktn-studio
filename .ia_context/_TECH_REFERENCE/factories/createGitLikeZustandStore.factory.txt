/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Git-like Zustand Store
 * -------------------------
 * This module exposes a factory (`createGitLikeZustandStoreFactory`) that creates a Zustand store
 * with a "git-like" workflow for any generic type T:
 *
 * - `stashData`: the current in-memory (volatile) working copy. Think "working tree".
 * - `commitData`: the last committed (optionally persisted) copy. Think "HEAD".
 *
 * The store provides a small set of strongly-typed primitives to mutate and move data between
 * these two layers:
 *
 *   - `stash(...)`: mutate only `stashData` (working copy). Overloaded to accept:
 *       • functional updater: (prev) => next
 *       • shallow partial (when T is a plain object)
 *       • full replacement
 *
 *   - `stashField(key, value)`: convenience setter for a single field (when T is a plain object).
 *
 *   - `commit(...)`: promote the working copy to the committed copy. Overloaded to:
 *       • commit()             → commit current stashData
 *       • commit((prev)=>next) → compute next from current stashData and commit
 *       • commit(partial)      → shallow merge with current stashData and commit (when T is plain)
 *       • commit(value)        → full replacement and commit
 *
 *   - `discard()`: rollback working copy to the last committed copy (stashData = commitData).
 *   - `resetStash()`: reset only the working copy to defaults.
 *   - `resetRepo()`: reset both stash and commit to defaults (also clears persisted data).
 *   - `getStash()` / `getCommit()`: fresh getters backed by `get()` (useful outside React).
 *
 * Persistence:
 *   - When `persistSaved` is true, only `commitData` is persisted (via sessionStorage/localStorage).
 *   - After hydration, we mirror `commitData → stashData` once so that the UI immediately
 *     reflects persisted data in the working copy.
 *
 * SSR-safety:
 *   - Storage selection is guarded with `typeof window` to avoid touching Web Storage on the server.
 */

import { create, StoreApi, UseBoundStore } from 'zustand';
import { persist, createJSONStorage, StateStorage } from 'zustand/middleware';
import { shallow } from 'zustand/shallow';

/**
 * Public store shape for a git-like state over generic T.
 * Note the TypeScript overloads on `stash` and `commit`:
 * - If T is a plain object, partial shallow patches are allowed.
 * - Otherwise (primitive/array/instance), only functional/full replacement applies.
 */
export type GitLikeState<T> = {
  /** Working copy (volatile). Drives UI. */
  stashData: T;
  /** Last committed copy (optionally persisted). */
  commitData: T;

  /** Mutate working copy (see overloads). */
  stash(patch: (prev: T) => T): void;
  stash(patch: T extends Record<string, any> ? Partial<T> : never): void;
  stash(value: T): void;

  /**
   * Set single field in working copy (only when T is a plain object).
   * No-op if T is not plain.
   */
  stashField: T extends Record<string, any>
    ? <K extends keyof T>(key: K, value: T[K]) => void
    : never;

  /** Commit working copy to committed copy (see overloads). */
  commit(): void;
  commit(patch: (prev: T) => T): void;
  commit(patch: T extends Record<string, any> ? Partial<T> : never): void;
  commit(value: T): void;

  /** Rollback working copy to the committed copy. */
  discard: () => void;
  /** Reset only working copy to defaults. */
  resetStash: () => void;
  /** Reset both working + committed copies to defaults. */
  resetRepo: () => void;

  /** Fresh getters (bypass React selectors; useful in services, effects, etc.). */
  getStash: () => T;
  getCommit: () => T;
};

/** Exported store type alias for convenience. */
export type GitLikeStore<T> = UseBoundStore<StoreApi<GitLikeState<T>>>;

/** Factory params for creating a git-like store over T. */
export type CreateGitLikeZustandStoreParams<T> = {
  /** Default value used to initialize BOTH stashData and commitData. */
  defaults: T;
  /** Unique key used for Web Storage persistence (when enabled). */
  storageKey: string;
  /** Storage backend to use for persistence. Defaults to sessionStorage. */
  storage?: 'session' | 'local';
  /** Whether to persist `commitData` to Web Storage. Defaults to true. */
  persistSaved?: boolean;
};

/**
 * Storage “no-op” for SSR:
 * - Satisfies the `StateStorage` interface without touching Web Storage.
 */
const noopStorage: StateStorage = {
  getItem: () => null,
  setItem: () => {
    /* noop */
  },
  removeItem: () => {
    /* noop */
  },
};

/**
 * Factory that builds a Zustand store with git-like semantics for a given T.
 *
 * Usage pattern:
 *   const useProfileStore = createGitLikeZustandStoreFactory<Profile>({
 *     defaults: { name: '', email: '' },
 *     storageKey: 'profile',
 *     storage: 'session',
 *     persistSaved: true,
 *   })
 *
 *   // In a component:
 *   const stash = useProfileStore(s => s.stashData)     // subscribe to working copy
 *   const commit = useProfileStore(s => s.commit)
 *   const stashField = useProfileStore(s => s.stashField)
 *
 *   // Edit:
 *   stashField('name', 'Ada')
 *   // Commit:
 *   commit()
 */
export function createGitLikeZustandStoreFactory<T>({
  defaults,
  storageKey,
  storage = 'session',
  persistSaved = true,
}: CreateGitLikeZustandStoreParams<T>): GitLikeStore<T> {
  /**
   * SSR-safe storage provider:
   * - On the server, return a no-op storage (never undefined).
   * - On the client, pick sessionStorage or localStorage as requested.
   */
  const storageProvider = (): StateStorage => {
    if (typeof window === 'undefined') {
      return noopStorage;
    }
    return storage === 'local' ? window.localStorage : window.sessionStorage;
  };

  /**
   * Defensive clone for plain objects, to avoid sharing references between:
   * - initial defaults → stashData/commitData
   * - commitData → stashData (discard/hydration)
   * Non-plain values (primitives/arrays/instances) are returned as-is.
   */
  const cloneIfPlain = (v: T) =>
    isPlainObject(v) ? ({ ...(v as any) } as T) : v;

  /**
   * Core store creator (passed to Zustand).
   * Implements all mutations with immutable updates (no immer dependency).
   */
  const creator = (set: any, get: any): GitLikeState<T> => ({
    // Initialize with cloned defaults to prevent shared refs
    stashData: cloneIfPlain(defaults),
    commitData: cloneIfPlain(defaults),

    /**
     * Update working copy (stashData).
     * Overloads supported:
     *  - functional updater: (prev) => next
     *  - shallow partial (when T is plain)
     *  - full replacement
     */
    stash: ((patch: unknown): void => {
      set((s: GitLikeState<T>) => {
        // Functional form: always allowed
        if (typeof patch === 'function') {
          const next = (patch as (prev: T) => T)(s.stashData);
          return { stashData: next };
        }
        // Shallow merge for plain objects (partial patch)
        if (isPlainObject(patch)) {
          if (isPlainObject(s.stashData)) {
            return {
              stashData: { ...(s.stashData as any), ...(patch as any) } as T,
            };
          }
          // If current is not plain, treat as full replacement
          return { stashData: patch as T };
        }
        // Full replacement for non-plain values
        return { stashData: patch as T };
      });
    }) as GitLikeState<T>['stash'],

    /**
     * Set a single field on working copy.
     * - Only when T is a plain object; otherwise it's a no-op.
     * - Shallow semantic: nested objects are replaced, not merged deeply.
     */
    stashField: ((key: any, value: any): void => {
      set((s: GitLikeState<T>) => {
        if (isPlainObject(s.stashData)) {
          return { stashData: { ...(s.stashData as any), [key]: value } as T };
        }
        return { stashData: s.stashData };
      });
    }) as GitLikeState<T>['stashField'],

    /**
     * Commit working copy to committed copy.
     * Overloads:
     *  - commit()                          → commit current stashData
     *  - commit((prev)=>next)              → compute next from stashData, then commit
     *  - commit(partial) [plain T only]    → shallow-merge with stashData, then commit
     *  - commit(value)                     → full replacement, then commit
     *
     * Note: `commit` also updates `stashData` to the same `next` value so that UI
     * immediately reflects the committed state.
     */
    commit: ((arg?: unknown): void => {
      set((s: GitLikeState<T>) => {
        let next: T;
        if (typeof arg === 'function') {
          next = (arg as (prev: T) => T)(s.stashData);
        } else if (arg !== undefined) {
          if (isPlainObject(arg) && isPlainObject(s.stashData)) {
            next = { ...(s.stashData as any), ...(arg as any) } as T;
          } else {
            next = arg as T;
          }
        } else {
          next = s.stashData;
        }
        return { stashData: next, commitData: next };
      });
    }) as GitLikeState<T>['commit'],

    /**
     * Discard working copy changes by restoring from committed copy.
     * Clones when plain object to prevent shared references.
     */
    discard: () =>
      set((s: GitLikeState<T>) => ({
        stashData: cloneIfPlain(s.commitData),
      })),

    /** Reset only the working copy to initial defaults (cloned). */
    resetStash: () => set({ stashData: cloneIfPlain(defaults) }),

    /** Reset both working + committed copies to initial defaults (cloned). */
    resetRepo: () =>
      set({
        stashData: cloneIfPlain(defaults),
        commitData: cloneIfPlain(defaults),
      }),

    /** Fresh getters (safe to use in async flows or utilities). */
    getStash: () => get().stashData,
    getCommit: () => get().commitData,
  });

  // In-memory mode: skip persistence entirely
  if (!persistSaved) {
    return create<GitLikeState<T>>(creator);
  }

  /**
   * Persistence mode:
   * - Persist ONLY `commitData` (source of truth).
   * - After hydration completes, mirror commitData → stashData once,
   *   so the UI starts from the persisted state immediately.
   */
  const store = create<GitLikeState<T>>()(
    persist(creator, {
      name: storageKey,
      storage: createJSONStorage(storageProvider),
      // Only persist committed state
      partialize: (state) => ({ commitData: state.commitData }),
      // Hydration hook (runs after state is rehydrated)
      onRehydrateStorage: () => (_state, _error) => {
        const current = store.getState();
        const next = cloneIfPlain(current.commitData);
        store.setState({ stashData: next });
      },
    }),
  );

  return store;
}

/**
 * Narrow utility: true for "plain" objects (objects whose prototype is Object.prototype
 * or null; arrays are excluded). Used to decide when shallow merging / cloning is safe.
 */
function isPlainObject(value: unknown): value is Record<string, unknown> {
  if (Object.prototype.toString.call(value) !== '[object Object]') return false;
  const proto = Object.getPrototypeOf(value);
  return proto === null || proto === Object.prototype;
}

/**
 * Re-export Zustand's shallow comparator for convenient selector memoization:
 *   const valueAndError = useStore(
 *     s => [s.stashData.value, s.stashData.isError] as const,
 *     shallowEq
 *   )
 */
export const shallowEq = shallow;
