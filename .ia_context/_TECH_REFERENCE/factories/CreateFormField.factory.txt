'use client'
/* eslint-disable @typescript-eslint/no-explicit-any */
import * as React from 'react'

/**
 * CreateFormField v3 — with optional debounced validation
 * =======================================================
 *
 * Summary
 * -------
 * This factory creates a thin, controlled wrapper around a presentational input component.
 * It wires the component to a “git-like” store (stash/commit) and centralizes:
 *  - immediate stash updates on user input,
 *  - optional side-effects on change,
 *  - synchronous validation (optionally using other hooks/stores),
 *  - conditional auto-commit (only when there is no error),
 *  - and (optional) debounced validation to wait until the user stops typing.
 *
 * Why
 * ---
 * - Keep your UI component dumb and controlled: it just renders and calls `onChange`.
 * - Centralize cross-cutting concerns (validation/commit/side-effects) in one place.
 * - Allow validations that depend on other hooks safely via `useExtra()`.
 * - Reduce validation noise with `validateWithDebounce` so errors are shown after the user pauses typing.
 *
 * Debounce behavior
 * -----------------
 * - If `validateWithDebounce` is `true`, validation (and conditional commit) runs
 *   only after the user has stopped typing for `debounceDelay` milliseconds.
 * - `debounceDelay` is optional; default is 500ms.
 * - A minimum of 500ms is enforced: `debounceDelay = Math.max(500, debounceDelay ?? 500)`.
 * - Stash updates and `onChangeEffect` still run immediately on each keystroke.
 *
 * Data flow on user change
 * ------------------------
 * 1) Write into stash: `stashField('value', newValue)` + `stashField('isEdited', true)`.
 * 2) Run optional `onChangeEffect(newValue)` (non-blocking).
 * 3) Validate:
 *    - immediate if `validateWithDebounce` is false,
 *    - debounced if `validateWithDebounce` is true.
 * 4) If `commitOnChange` is enabled and there is no error → call `commit?.()`.
 *
 * Types
 * -----
 * T: Stash shape for this field (must include `value`, `isError`, `isDisabled`, `isEdited`, `errorMessage`).
 * P: Extra props forwarded to the presentational component (and to `validate`).
 * E: “Extra” data produced by `useExtra()`; typically derived from other hooks/stores/contexts.
 */

/** Pure, synchronous validator signature. Returns error message or `null` if valid. */
type ValidateFn<T, P, E> = (value: T, props: P, extra: E) => string | null

/**
 * Fallback hook used when no `useExtra` is provided.
 * Always called to preserve hook call order and satisfy the Rules of Hooks.
 */
function useNoopExtra<E>(): E {
  return undefined as unknown as E
}

/**
 * CreateFormField
 * ---------------
 * @template T Stash state shape. Must include:
 *            - value: any
 *            - isError: boolean
 *            - isDisabled: boolean
 *            - isEdited: boolean
 *            - errorMessage: string
 * @template P Extra props forwarded to your presentational component and validator.
 * @template E Extra data returned by `useExtra()` (derived from hooks/stores/contexts).
 *
 * @param params.useStore
 *  Hook that exposes the field stash and mutators:
 *   - stash: T
 *   - stashField: (key: keyof T, value: any) => void
 *   - commit?: () => void
 *
 * @param params.validate
 *  Optional pure, synchronous validator:
 *   (value, props, extra) => string | null
 *  Return an error message to invalidate the field, or `null` when valid.
 *
 * @param params.useExtra
 *  Optional hook that runs **inside** the wrapper to read from other hooks/stores.
 *  Whatever it returns is forwarded as the 3rd param (`extra`) to `validate`.
 *
 * @returns A controlled wrapper component:
 *  <Field
 *    Component={YourInput}
 *    commitOnChange={true | (value, props) => boolean}
 *    onChangeEffect={(value) => void | Promise<void>}
 *    validateWithDebounce?={boolean}
 *    debounceDelay?={number} // optional, defaults to 500ms, min 500ms
 *    {...props (P)}
 *  />
 */
export function CreateFormField<
  T extends {
    value: any
    isError: boolean
    isDisabled: boolean
    isEdited: boolean
    errorMessage: string
  },
  P extends Record<string, any> = Record<string, any>,
  E = unknown
>({
  useStore,
  validate,
  useExtra,
}: {
  useStore: () => {
    stash: T
    stashField: (key: keyof T, value: any) => void
    commit?: () => void
  }
  validate?: ValidateFn<T['value'], P, E>
  useExtra?: () => E
}) {
  return function FormField({
    Component,
    commitOnChange = false,
    onChangeEffect,
    validateWithDebounce = false,
    debounceDelay, // optional; default applied below
    ...restProps
  }: {
    Component: React.ComponentType<
      {
        value: T['value']
        isError: boolean
        isDisabled: boolean
        errorText?: string
        onChange: (val: T['value']) => void
      } & P
    >
    /** If `true`, run validation (and possible commit) on a debounce instead of immediately. */
    validateWithDebounce?: boolean
    /**
     * Optional debounce delay in ms; defaults to 500ms.
     * A minimum of 500ms is enforced.
     */
    debounceDelay?: number
    /** Commit immediately after a successful validation (boolean), or decide per change via predicate. */
    commitOnChange?: boolean | ((value: T['value'], props: P) => boolean)
    /** Side-effect executed on every change after stash write (non-blocking). */
    onChangeEffect?: (value: T['value']) => void | Promise<void>
  } & P): React.ReactElement {
    const { stash, stashField, commit } = useStore() as any

    // Always call a hook for `extra` to satisfy the Rules of Hooks:
    const useResolvedExtra = useExtra ?? useNoopExtra<E>
    const extra = useResolvedExtra()

    // --- Debounce infrastructure -------------------------------------------
    // Keep track of a pending validation timer and the last typed value.
    const timerRef = React.useRef<ReturnType<typeof setTimeout> | null>(null)
    const lastValueRef = React.useRef<T['value']>(stash.value)

    // Apply default and minimum (500ms)
    const effectiveDelay = Math.max(500, debounceDelay ?? 500)

    const clearTimer = () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current)
        timerRef.current = null
      }
    }

    /**
     * Runs validation and (if applicable) commit for a given value.
     * This is invoked immediately or from the debounce timer.
     */
    const runValidationAndMaybeCommit = (value: T['value']) => {
      let hasError = false

      if (validate && !stash.isDisabled) {
        const propsForValidation = restProps as unknown as P
        const errorMsg = validate(value, propsForValidation, extra)

        if (errorMsg) {
          hasError = true
          stashField('isError', true)
          stashField('errorMessage', errorMsg)
        } else {
          stashField('isError', false)
          stashField('errorMessage', '')
        }
      }

      const shouldCommit =
        typeof commitOnChange === 'function'
          ? commitOnChange(value, restProps as unknown as P)
          : !!commitOnChange

      if (shouldCommit && !hasError) {
        commit?.()
      }
    }

    /**
     * Unified change handler
     * 1) Immediate stash write + mark edited
     * 2) Optional side-effect (non-blocking)
     * 3) Validation (immediate or debounced)
     */
    const handleChange = (newValue: T['value']) => {
      // 1) Stash
      stashField('value', newValue)
      stashField('isEdited', true)

      // 2) Side-effect (fire-and-forget)
      if (onChangeEffect) {
        try {
          const maybe = onChangeEffect(newValue)
          if (maybe instanceof Promise) {
            maybe.catch((err) => {
              console.error('[FormField:onChangeEffect async error]:', err)
            })
          }
        } catch (err) {
          console.error('[FormField:onChangeEffect] error:', err)
        }
      }

      // 3) Validation strategy
      if (validateWithDebounce) {
        lastValueRef.current = newValue
        clearTimer()
        timerRef.current = setTimeout(() => {
          runValidationAndMaybeCommit(lastValueRef.current)
        }, effectiveDelay)
      } else {
        runValidationAndMaybeCommit(newValue)
      }
    }

    // Cleanup pending timer on unmount
    React.useEffect(() => {
      return () => clearTimer()
    }, [])

    return (
      <Component
        value={stash.value}
        isError={stash.isError}
        isDisabled={stash.isDisabled}
        errorText={stash.errorMessage}
        onChange={handleChange}
        {...(restProps as unknown as P)}
      />
    )
  }
}

/* -----------------------------------------------------------------------------
Usage Example

type TextStash = {
  value: string
  isError: boolean
  isDisabled: boolean
  isEdited: boolean
  errorMessage: string
}

type LastNameProps = {
  id: string
  label?: string
  t: (key: string) => string
  isLoading: boolean
}

const LastNameField = CreateFormField<TextStash, LastNameProps, { name: string | null }>({
  useStore: () => ({ stash, stashField, commit }),
  useExtra: () => ({ name: useNameStash().value ?? null }),
  validate: (value, props, extra) => {
    if (!value?.trim()) return props.t('error.lastNameRequired')
    if (!extra.name)    return props.t('error.lastNameRequiresNameFirst')
    return null
  },
})

// In a form (debounced validation):
<LastNameField
  Component={TextInput}
  validateWithDebounce
  debounceDelay={800} // optional; defaults to 500, min 500
  commitOnChange={(v) => (v?.toString().trim().length ?? 0) >= 3}
  onChangeEffect={(v) => analytics.track('lastName_changed', { v })}
  id="lastName"
  t={t}
  isLoading={false}
/>
----------------------------------------------------------------------------- */
